<div id="top"></div>

# Introduction

<details>

<summary>Table of contents</summary>

- [JDK Architecture](#jdk-architecture)
- [Compilation Flow](#compilation-flow)
- [Java Program Skeleton](#-java-program-skeleton)
- [Reading Input from Keyboard](#reading-input-from-keyboard)
- [JVM Architecture](#jvm-architecture)
- [Primitive Types](#primitive-types)
- [Primitive Types vs Reference Types](#primitive-types-vs-reference-types)
- [Parameters vs Arguments](#parameters-vs-arguments)
- [Strings](#strings)
- [Escape Sequences](#Escape-Sequences)
- [Arrays](#arrays)
- [Multi-dimensional Arrays](#multi-dimensional-arrays)
- [Constants](#constants)
- [Arithmetic Expressions](#arithmetic-expressions)
- [Order of Operations](#order-of-operations-operator-precedence)
- [Casting](#casting)
- [Math Class](#the-math-class)
- [Formatting Numbers](#formatting-numbers)

</details>

## JDK Architecture

<table>
    <tr>
        <th>JDK Architecture</th>
    </tr>
    <tr>
        <td>
            <img src="https://github.com/user-attachments/assets/29f54eae-0dde-48b3-911f-d9ce346fa046" width="100%" title="JDK Architecture"/>
        </td>
    </tr>
</table>

<hr/>

## Compilation Flow

- First.jav (Source Code) ----> Java c (Java Compiler - from jdk) ---> First.class (Byte code)

- We can run the Java Byte code (\*.class file) on any system had JRE (Java Runtime Environment)

- JRE contains JVM (Java Virtual Machine)

- We can download Java Virtual Machine for so many systems in their native

- Byte Code (\*.class) -> JVM -> Native Code (Windows, mac,..)

- So, Java is platform independent

**Java compilation:** javac Filename.java <br>
**Run Java Program1:** java com.decider.Main (if class was inside a package) <br>
**Run Java Program2:** java Main (if class was not inside a package)

<hr/>

## ‚òï Java Program Skeleton

### The Basic File Structure

All executable Java code must reside within a class. The file name **must** match the public class name.

**File Name:** `MyApplication.java`

```java
public class MyApplication {
    // Execution starts here
    public static void main(String[] args) {
        // --- Your application logic goes inside here ---

        System.out.println("Hello, Java World!");
    }
}
```

### Key Notes

- when class is declared public, only then file name and class name should be same
- we need the main method to start execution
- If a class (or nested class) is defined, the compiler will create a corresponding .class file for all classes in the program.
- to run the .class file it should contain main method
- So when you run a java program(java First) it will start executing the .class file, and it starts searching for main function.

<hr/>

## Reading Input from Keyboard

```java
  import java.lang.*;   #default package
  import java.util.*;   # for scanner class

  Scanner sc = new Scanner(System.in); // We provide input stream as param - System.in

  nextInt()
  nextFloat()
  nextDouble()
  next() - reads only 1 word
  nextLine() - reads multiple words
```

<hr/>

## JVM Architecture

-> Memory

+-------------------+
|   Code Section    |
|  (Method Area)    |
+-------------------+
|       Heap        |
|   (Objects)       |
+-------------------+
|       Stack       |
| (Local Variables) |
+-------------------+

- **Heap** - where objects are created (dynamic)
- **stack** - where local variables and references are created
- **code section** - contains the code (class Loader loads the code, - **Interpreter/JIT** - just in time compilation will interpret the code)

<p align="right"><a href="#top">‚¨ÜÔ∏è Back to Top</a></p>

<hr/>

## Primitive Types

- **Primitive**: For storing simple values
- **Reference**: For storing complex objects

<img src="https://github.com/user-attachments/assets/1c80480c-fede-45e1-a440-bbdca9c9d3ba" width="100%" title="JDK Architecture"/>

Code:

```java
package com.decider;

public class Main {
    public static void main(String[] args) {
        byte age = 23;
        short yearOfBirth = 2002;
        int favoriteNumber = 11;
        long viewsCount = 3_123_456_789L;
        float playerRating = 9.99f;
        double price = 9_999_999_999.99;
        boolean isEligible = true;
        char initial = 'M';
    }
}
```

- when declaring primitive types we don't need to declare memory, memory is allocated and released by JRE automatically
- for reference types we need to always allocate memory, no need to release memory JRE will take care of that. (we use new keyword)

```java
package com.decider;

import java.util.Date;

public class Main {
    public static void main(String[] args) {
        byte age = 23;
        Date now = new Date();
        System.out.println(now); //shortcut: sout + tab
    }
}
```

<hr/>

## Primitive Types vs Reference Types

```java
package com.decider;

import java.awt.*;

public class Main {
    public static void main(String[] args) {
        byte a = 30;
        byte b = a;
        a = 1;
        System.out.println(a + " " + b); // 1 30
        Point point1 = new Point(1, 2);
        Point point2 = point1;
        point1.x = 11;
        System.out.println(point1 + " " + point2); // java.awt.Point[x=11,y=2] java.awt.Point[x=11,y=2]
    }
}
```

- Reference types are copied by the references (Above point1, point2 points to same addr that is allocated in memory)
- Primitive types are copied by the value

<hr/>

## Parameters vs Arguments

- **Parameters** are the holes that we define in the method
- **Arguments** are the actual values that we pass to the method

```
ex: message.replace(target: '!', replacement: '*');
Here target, replacement are parameters (these are defined at the time of method declaration)
and the '!','*' are arguments (actual values passed)
```

<hr/>

## Strings

### 1. Declaration:

```java
String traditional = new String("Hello World"); // Using new String() always creates a new object in heap.
String shortHand = "Simple"; // Using string literals ("...") stores/reuses them in the String constant pool, making it memory-efficient.
System.out.println(traditional);
System.out.println(shortHand);
```

**Case-1**: new String("Hello World")

- "Hello World" ‚Üí first stored in String Constant Pool (SCP) (in heap).
- new String(...) ‚Üí creates a new copy of that same content in the regular heap area (outside SCP).
- So you get two objects in memory:

```
SCP: "Hello World"
Heap: new String("Hello World") ‚Üí separate object with same content
```

- The variable traditional ‚Üí points to the heap object, not the pooled one.
- Hence, **extra memory** used unnecessarily.

**Case-2**: "Hello World"

- JVM checks the String Constant Pool (SCP):
  - If "Hello World" exists ‚Üí reuse it.
  - If not ‚Üí create it once and reuse later.
- So only one object created or reused.
- The variable shortHand ‚Üí directly refers to the pooled string.
- Hence, **memory-efficient** ‚úÖ.

### 2. Behaviour:

- Strings are immutable (Once created, their value cannot be changed.)
- Any modification (like concatenation, replace, etc.) creates a new String object.

## 3. Intro to some methods

```java
String test ="   Hello World" + "!!  ";
System.out.println(test.toLowerCase()); //will return string - hello world!!
System.out.println(test.replace('!', '*')); // Hello World**
System.out.println(test.indexOf("orld")); // 10
System.out.println(test.trim()); // Hello World!!
System.out.println(test); //   Hello World!!
```

<p align="right"><a href="#top">‚¨ÜÔ∏è Back to Top</a></p>

<hr/>

## Escape Sequences

### 1. Declaration - \

```java
System.out.println("hi\tthere\nfile\" is located\": C:\\Windows\n Search it");
```

### 2. Behaviour

- Escape sequences are special character combinations starting with \ that represent characters which can‚Äôt be typed or printed directly.

### 3. Under the hood

- **Step-1**: ‚Äî Compile-Time Translation

  ```java
  String s = "Hello\nWorld";
  ```

  - The Java compiler (javac) reads the source code textually.
  - When it sees \n, it does not store backslash + n literally.
  - It replaces them with the single Unicode character that represents newline (line feed, U+000A).
  - So internally, the compiler turns:

  ```
  "Hello\nWorld"
  "Hello<0x000A>World"
  ```

  (where <0x000A> is the newline character in Unicode/ASCII).

- **Step-2**: ‚Äî Stored in String Constant Pool

  - That compiled string literal is stored in the class file‚Äôs constant pool (not SCP yet) in UTF-8 or modified UTF-8 encoding.
  - When the class loads, the JVM moves it into the String Constant Pool (SCP).

- **Step-3**: ‚Äî Runtime Behavior
  - At Runtime
    - When the JVM executes System.out.println(s);
    - It reads that string from the pool
    - The internal character array in String contains actual characters like:
    ```
    ['H', 'e', 'l', 'l', 'o', '\n', 'W', 'o', 'r', 'l', 'd']
    ```
    - The \n is interpreted by the output stream (console) as a newline action, not as literal \ and n.

### 4. Summary

- Escape sequences are compile-time translations ‚Äî
- they don‚Äôt exist as special runtime symbols.
- After compilation, the actual character codes are stored directly in the string object.

### 5. Special Case ‚Äî Unicode Escapes

- Java also supports \u Unicode escapes, which are processed before lexical parsing.

```java
System.out.println("\u0048\u0065\u006C\u006C\u006F"); \\Hello
```

<p align="right"><a href="#top">‚¨ÜÔ∏è Back to Top</a></p>

<hr/>

## Arrays

```java
package com.javapractise;

import java.util.Arrays;

class Main {
    public static void main(String[] args) {
        int[] numbers = new int[5]; // Declaration - 1
        numbers[0]=11;
        numbers[1]=13;
        System.out.println(Arrays.toString(numbers)); // [11, 13, 0, 0, 0]

        int[] preKnown = {11,23,4,5,6}; // Declarataion - 2 
        System.out.println(preKnown.length); // 5
        Arrays.sort(preKnown);
        System.out.println(Arrays.toString(preKnown)); // [4, 5, 6, 11, 23]
    }
}
```

1) In Java, arrays are part of the language syntax, not full objects from a class like Array ‚Äî
   so Java provides a utility class java.util.Arrays to operate on them externally.

2) The deeper reason (under the hood)

    - Arrays are built-in language constructs
        When you declare:
    ```java
    int[] nums = {1, 2, 3};
    ```
    the JVM creates a special array object ‚Äî
    but its structure and methods are defined by the JVM, not by a user-visible Array class.

    So nums doesn‚Äôt have methods like:
    ```java
    nums.sort(); ‚ùå
    nums.fill(0); ‚ùå
    ```

    - Java separates data structures from utilities
    Java‚Äôs design philosophy (since the early days):
    ```
        Keep core language types minimal and stable,
        and provide reusable operations through static utility classes.
    ```

        That‚Äôs why:

            - Arrays ‚Üí static methods for array operations

            - Collections ‚Üí static methods for List, Set, Map

            - Math ‚Üí static math operations

            - Objects ‚Üí static null-safe helpers

            This gives clarity, performance, and no hidden overhead on primitive arrays.

    - Arrays in Java are not like JavaScript or Python lists

        Languages like Python or JS make arrays true objects with dynamic prototypes (methods inside them).
        Java doesn‚Äôt ‚Äî it‚Äôs statically typed and JVM-backed, so array behavior is baked in at the VM level for speed.


    - Summary

        | Concept            | Explanation                                        |
        | ------------------ | -------------------------------------------------- |
        | `int[]`            | Language-level array, not a full class             |
        | `java.util.Arrays` | Utility class with static methods                  |
        | Why separate       | Keeps JVM-level performance and clean design       |
        | Methods available  | sort, binarySearch, copyOf, fill, equals, toString |

    - In short:
        Java arrays = simple, fast memory blocks managed by JVM.
        Arrays class = helper toolkit to manipulate them safely and efficiently.

<p align="right"><a href="#top">‚¨ÜÔ∏è Back to Top</a></p>

<hr/>

## Multi-dimensional Arrays

```java
package com.javapractise;

import java.util.Arrays;

class Main {
    public static void main(String[] args) {
        int[][] numbers = new int[2][3]; // Declaration - 1
        numbers[0][0]=11;
        numbers[1][0]=13;
        System.out.println(Arrays.deepToString(numbers)); // [[11, 0, 0], [13, 0, 0]]
        int[][] preKnown = {{1,2,3},{4,5,6}};
        System.out.println(preKnown.length); // row-len: 2
        System.out.println(preKnown[0].length); // col-len: 3
        System.out.println(Arrays.deepToString(preKnown)); // [[1, 2, 3], [4, 5, 6]]
    }
}
```

<hr/>

## Constants

 - We declare constants using **final** keyword.

```java
package com.javapractise;

class Main {
    public static void main(String[] args) {
        final float PI = 3.14F; // Declaration
        System.out.println(PI);
    }
}
```

<hr/>

## Arithmetic Expressions

```java
package com.javapractise;

class Main {
    public static void main(String[] args) {
        int add = 4 + 2;
        int sub = 4 - 2;
        int mul = 4 * 2;
        int div = 4 / 2;
        int rem = 4 % 2;
        double divDouble = (double)4 / (double)2;
        System.out.println(divDouble);

        int x = 1;
        int y = ++x; // prefix operator
        int z = x++; // postfix operator
        System.out.println("x:" + x + " y:" + y + " z:" + z);
        
        //Augmented or compound operator
        x+=10;
        System.out.println(x);
    }
}
```

<hr/>

## Order of Operations (Operator Precedence)

### üß© Basic Precedence Rules
1Ô∏è‚É£ **Parentheses `( )`** ‚Üí Highest priority  
2Ô∏è‚É£ **Multiplication, Division, Modulus** ‚Üí `*  /  %`  
3Ô∏è‚É£ **Addition, Subtraction** ‚Üí `+  -`

### üß† Example
```java
int x = (10 * 3) + 2; // 32
```

<hr/>

## Casting

```java
package com.javapractise;

class Main {
    public static void main(String[] args) {
        // Implicit Casting - it is automatic, converting smaller data type to bigger data type, No Data Loss
        // byte > short > int > long > float > double
        short x = 1;
        int y = x + 2; // here x is copies to anonymous int memory location since short(2 bytes) can be stored in int(4 bytes), and then addition takes place
        System.out.println(y); // 3

        // Explicit Casting - it is manual, converting bigger data type to smaller data type, Data Loss
        // double > float > long > int > short > byte
        double p = 1.1;
        int q = (int)p +2;
        System.out.println(q); // 3

        String a = "1";
        int b = Integer.parseInt(a) + 10;
        System.out.println(b); // 11
    }
}
```

<hr/>

## The Math Class

- No need to import Math class it will be provided by default in java.lang package

```java
package com.javapractise;

class Main {
    public static void main(String[] args) {
        int result1 = Math.round(1.5F); // 1
        int result2 = (int)Math.ceil(2.1D); // 3
        int result3 = (int) Math.floor(4.9F); // 4
        int result4 = Math.max(10, 11); // 11
        int result5 = Math.min(10,11);  // 10
        int result6 = (int) (Math.random() * 100); // 31 - random function gives b/w 0 to 1
    }
}
```
<hr/>

## Formatting Numbers

```java
package com.javapractise;

import java.text.NumberFormat;
import java.util.Currency;

class Main {
    public static void main(String[] args) {
        NumberFormat currency = NumberFormat.getCurrencyInstance();
        currency.setCurrency(Currency.getInstance("USD"));
        String usdAmount = currency.format(123456.891);
        System.out.println(usdAmount); // $123,456.89
        currency.setCurrency(Currency.getInstance("INR"));
        String inrAmount = currency.format(1234567.89);
        System.out.println(inrAmount); // ‚Çπ1,234,567.89

        NumberFormat percent = NumberFormat.getPercentInstance();
        String pointOnePercent = percent.format(0.1);
        System.out.println(pointOnePercent); // 10%
    }
}
```
