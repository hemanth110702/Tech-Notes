<div id="top"></div>

# Introduction

<details>

<summary>Table of contents</summary>

- [JDK Architecture](#jdk-architecture)
- [Compilation Flow](#compilation-flow)
- [Java Program Skeleton](#-java-program-skeleton)
- [Reading Input from Keyboard](#reading-input-from-keyboard)
- [JVM Architecture](#jvm-architecture)
- [Primitive Types](#primitive-types)
- [Primitive Types vs Reference Types](#primitive-types-vs-reference-types)
- [Parameters vs Arguments](#parameters-vs-arguments)
- [Strings](#strings)
- [Escape Sequences](#Escape-Sequences)

</details>

## JDK Architecture

<table>
    <tr>
        <th>JDK Architecture</th>
    </tr>
    <tr>
        <td>
            <img src="https://github.com/user-attachments/assets/29f54eae-0dde-48b3-911f-d9ce346fa046" width="100%" title="JDK Architecture"/>
        </td>
    </tr>
</table>

<hr/>

## Compilation Flow

- First.jav (Source Code) ----> Java c (Java Compiler - from jdk) ---> First.class (Byte code)

- We can run the Java Byte code (\*.class file) on any system had JRE (Java Runtime Environment)

- JRE contains JVM (Java Virtual Machine)

- We can download Java Virtual Machine for so many systems in their native

- Byte Code (\*.class) -> JVM -> Native Code (Windows, mac,..)

- So, Java is platform independent

**Java compilation:** javac Filename.java
**Run Java Program1:** java com.decider.Main (if class was inside a package)
**Run Java Program2:** java Main (if class was not inside a package)

<hr/>

## ☕ Java Program Skeleton

### The Basic File Structure

All executable Java code must reside within a class. The file name **must** match the public class name.

**File Name:** `MyApplication.java`

```java
public class MyApplication {
    // Execution starts here
    public static void main(String[] args) {
        // --- Your application logic goes inside here ---

        System.out.println("Hello, Java World!");
    }
}
```

### Key Notes

- when class is declared public, only then file name and class name should be same
- when there is no public class defined
- If a class (or nested class) is defined, the compiler will create a corresponding .class file for all classes in the program.
- to run the .class file it should contain main method
- So when you run a java program(java First) it will start executing the .class file, and it starts searching for main function.

<hr/>

## Reading Input from Keyboard

```
  import java.lang.*;   #default package
  import java.util.*;   # for scanner class

  Scanner sc = new Scanner(System.in); // We provide input stream as param - System.in

  nextInt()
  nextFloat()
  nextDouble()
  next() - reads only 1 word
  nextLine() - reads multiple words
```

<hr/>

## JVM Architecture

-> Memory

- **Heap** - where objects are created (dynamic)
- **stack** - where local variables and references are created
- **code section** - contains the code (class Loader loads the code, - **Interpreter/JIT** - just in time compilation will interpret the code)

<hr/>

## Primitive Types

- **Primitive**: For storing simple values
- **Reference**: For storing complex objects

<img src="https://github.com/user-attachments/assets/1c80480c-fede-45e1-a440-bbdca9c9d3ba" width="100%" title="JDK Architecture"/>

Code:

```
package com.decider;

public class Main {
    public static void main(String[] args) {
        byte age = 23;
        short yearOfBirth = 2002;
        int favoriteNumber = 11;
        long viewsCount = 3_123_456_789L;
        float playerRating = 9.99f;
        double price = 9_999_999_999.99;
        boolean isEligible = true;
        char initial = 'M';
    }
}
```

- when declaring primitive types we don't need to declare memory, memory is allocated and released by JRE automatically
- for reference types we need to always allocate memory, no need to release memory JRE will take care of that. (we use new keyword)

```
package com.decider;

import java.util.Date;

public class Main {
    public static void main(String[] args) {
        byte age = 23;
        Date now = new Date();
        System.out.println(now); //shortcut: sout + tab
    }
}
```

<hr/>

## Primitive Types vs Reference Types

```
package com.decider;

import java.awt.*;

public class Main {
    public static void main(String[] args) {
        byte a = 30;
        byte b = a;
        a = 1;
        System.out.println(a + " " + b); // 1 30
        Point point1 = new Point(1, 2);
        Point point2 = point1;
        point1.x = 11;
        System.out.println(point1 + " " + point2); // java.awt.Point[x=11,y=2] java.awt.Point[x=11,y=2]
    }
}
```

- Reference types are copied by the references (Above point1, point2 points to same addr that is allocated in memory)
- Primitive types are copied by the value

<hr/>

## Parameters vs Arguments

- **Parameters** are the holes that we define in the method
- **Arguments** are the actual values that we pass to the method

```
ex: message.replace(target: '!', replacement: '*');
Here target, replacement are parameters (these are defined at the time of method declaration)
and the '!','*' are arguments (actual values passed)
```

<hr/>

## Strings

### 1. Declaration:

```
String traditional = new String("Hello World"); // Using new String() always creates a new object in heap.
String shortHand = "Simple"; // Using string literals ("...") stores/reuses them in the String constant pool, making it memory-efficient.
System.out.println(traditional);
System.out.println(shortHand);
```

**Case-1**: new String("Hello World")

- "Hello World" → first stored in String Constant Pool (SCP) (in heap).
- new String(...) → creates a new copy of that same content in the regular heap area (outside SCP).
- So you get two objects in memory:

```
SCP: "Hello World"
Heap: new String("Hello World") → separate object with same content
```

- The variable traditional → points to the heap object, not the pooled one.
- Hence, **extra memory** used unnecessarily.

**Case-2**: "Hello World"

- JVM checks the String Constant Pool (SCP):
  - If "Hello World" exists → reuse it.
  - If not → create it once and reuse later.
- So only one object created or reused.
- The variable shortHand → directly refers to the pooled string.
- Hence, **memory-efficient** ✅.

### 2. Behaviour:

- Strings are immutable (Once created, their value cannot be changed.)
- Any modification (like concatenation, replace, etc.) creates a new String object.

## 3. Intro to some methods

```
String test ="   Hello World" + "!!  ";
System.out.println(test.toLowerCase()); //will return string - hello world!!
System.out.println(test.replace('!', '*')); // Hello World**
System.out.println(test.indexOf("orld")); // 10
System.out.println(test.trim()); // Hello World!!
System.out.println(test); //   Hello World!!
```

## Escape Sequences

### 1. Declaration - \

```
System.out.println("hi\tthere\nfile\" is located\": C:\\Windows\n Search it");
```

### 2. Behaviour

- Escape sequences are special character combinations starting with \ that represent characters which can’t be typed or printed directly.

### 3. Under the hood

- **Step-1**: — Compile-Time Translation

  ```
  String s = "Hello\nWorld";
  ```

  - The Java compiler (javac) reads the source code textually.
  - When it sees \n, it does not store backslash + n literally.
  - It replaces them with the single Unicode character that represents newline (line feed, U+000A).
  - So internally, the compiler turns:

  ```
  "Hello\nWorld"
  "Hello<0x000A>World"
  ```

  (where <0x000A> is the newline character in Unicode/ASCII).

- **Step-2**: — Stored in String Constant Pool

  - That compiled string literal is stored in the class file’s constant pool (not SCP yet) in UTF-8 or modified UTF-8 encoding.
  - When the class loads, the JVM moves it into the String Constant Pool (SCP).

- **Step-3**: — Runtime Behavior
  - At Runtime
    - When the JVM executes System.out.println(s);
    - It reads that string from the pool
    - The internal character array in String contains actual characters like:
    ```
    ['H', 'e', 'l', 'l', 'o', '\n', 'W', 'o', 'r', 'l', 'd']
    ```
    - The \n is interpreted by the output stream (console) as a newline action, not as literal \ and n.

### 4. Summary

- Escape sequences are compile-time translations —
- they don’t exist as special runtime symbols.
- After compilation, the actual character codes are stored directly in the string object.

### 5. Special Case — Unicode Escapes

- Java also supports \u Unicode escapes, which are processed before lexical parsing.

```
System.out.println("\u0048\u0065\u006C\u006C\u006F"); \\Hello
```
